#ifndef GRAPHICS_ENGINE_H
#define GRAPHICS_ENGINE_H

#include <nds.h>
#include <gl2d.h>
#include <stdio.h>
#include <stdarg.h>
#include "font.h"
#include "font_si.h"
#include "uvcoord_font_si.h"

void initSubSprites(void)
{
 
	oamInit(&oamSub, SpriteMapping_Bmp_2D_256, false);
 
	int x = 0;
	int y = 0;
 
	int id = 0;

	//set up a 4x3 grid of 64x64 sprites to cover the screen
	for(y = 0; y < 3; y++)
	for(x = 0; x < 4; x++)
	{
		oamSub.oamMemory[id].attribute[0] = ATTR0_BMP | ATTR0_SQUARE | (64 * y);
		oamSub.oamMemory[id].attribute[1] = ATTR1_SIZE_64 | (64 * x);
		oamSub.oamMemory[id].attribute[2] = ATTR2_ALPHA(1) | (8 * 32 * y) | (8 * x);
		id++;
	}
 
	swiWaitForVBlank();
 
	oamUpdate(&oamSub);
}

class GraphicsEngine {
public:
  typedef enum {
    SCREEN_TOP = 0,
    SCREEN_BOTTOM = 1
  } SelectedScreen;
  glImage FontImages[FONT_SI_NUM_IMAGES];
  Cglfont Font;
  u8 currentScreen;
  static GraphicsEngine * getInstance() {
    if(nullptr == instance) {
        instance = new GraphicsEngine();
        instance->currentScreen = 0;

        // Set it to my favorite mode
        videoSetMode(MODE_5_3D);
        videoSetModeSub(MODE_5_2D);

        // init sprite layer for background buffering
        initSubSprites();
        bgInitSub(3, BgType_Bmp16, BgSize_B16_256x256, 0, 0);	
        
        //consoleDemoInit();
        
        
        // Initialize GL in 3d mode
        glScreen2D();
        
        
        // Set  Bank A to texture (128 kb)
        vramSetBankA( VRAM_A_TEXTURE );
        

        vramSetBankE(VRAM_E_TEX_PALETTE);  // Allocate VRAM bank for all the palettes
        
        // Load our font texture
        // We used glLoadSpriteSet since the texture was made
        // with my texture packer.
        // no need to save the return value since
        // we don't need  it at all
        instance->Font.Load(instance->FontImages,				// pointer to glImage array
              FONT_SI_NUM_IMAGES, 		// Texture packer auto-generated #define
              font_si_texcoords,		// Texture packer auto-generated array
              GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
              TEXTURE_SIZE_64,			// sizeX for glTexImage2D() in videoGL.h
              TEXTURE_SIZE_128,		// sizeY for glTexImage2D() in videoGL.h
              GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
              256,						// Length of the palette (256 colors)
              (u16*)font_siPal,		// Palette Data
              (u8*)font_siBitmap		// image data generated by GRIT 
            );

        // calculate the amount of 
        // memory uploaded to VRAM in KB
        int TextureSize = font_siBitmapLen;

    }
    return instance;
  };
  void StartDrawing() {
    currentScreen=(currentScreen+1)&0x01;
		while(REG_DISPCAPCNT & DCAP_ENABLE);
		if((currentScreen & 1) == 0)
		{
			lcdMainOnBottom();
			vramSetBankC(VRAM_C_LCD);
			vramSetBankD(VRAM_D_SUB_SPRITE);
			REG_DISPCAPCNT = DCAP_BANK(2) | DCAP_ENABLE | DCAP_SIZE(3);
		}
		else
		{
			lcdMainOnTop();
			vramSetBankD(VRAM_D_LCD);
			vramSetBankC(VRAM_C_SUB_BG);
			REG_DISPCAPCNT = DCAP_BANK(3) | DCAP_ENABLE | DCAP_SIZE(3);
		}
		
		glBegin2D();
  }
  void StopDrawing() {
    glEnd2D();
		glFlush(0);
  }
  void DrawScope(s16* buffer, int length, u16 color) {
    for(int i=0; i<length - 1; i++) {
        s16 sample = buffer[i];
        s16 nextSample = buffer[i+1];
        glLine(
            i*(SCREEN_WIDTH/length), (SCREEN_HEIGHT>>1) + ((sample*SCREEN_HEIGHT)>>16),
            (i+1)*(SCREEN_WIDTH/length), (SCREEN_HEIGHT>>1) + ((nextSample*SCREEN_HEIGHT)>>16),
            color
        );
    }
  }
  ~GraphicsEngine() = default;
private:
  static GraphicsEngine * instance;
  GraphicsEngine() = default;
  GraphicsEngine(const GraphicsEngine&)= delete;
  GraphicsEngine& operator=(const GraphicsEngine&)= delete;
};
GraphicsEngine * GraphicsEngine::instance = nullptr;

void printf(int x, int y, u16 color, const char * format, ... )
{
  char buffer[256];
  va_list args;
  va_start (args, format);
  vsprintf (buffer, format, args);
  glColor(color);
  GraphicsEngine::getInstance()->Font.Print(x, y, buffer);
  va_end (args);
}

#endif